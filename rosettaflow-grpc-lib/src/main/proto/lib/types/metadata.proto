syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.platon.rosettaflow.grpc.service";
option java_outer_classname = "MetaDataProto";
package types;

import "lib/common/base.proto";


option go_package = "github.com/RosettaFlow/Carrier-Go/lib/types";

// MetaData body data struct.
message MetaData {
  string                      identity_id = 1;                // 元数据所属的组织的 身份标识
  string                      node_id = 2;                    // 元数据所属的组织的 p2p公钥
  string                      node_name = 3;                  // 元数据所属的组织的 组织名称
  string                      data_id = 4;                    //
  api.protobuf.DataStatus     data_status = 5;                // the status of data, N means normal, D means deleted.
  string                      origin_id = 6;                  // 元数据引用的原始文件Id
  string                      table_name = 7;                 // 元数据的名称 (对外的表名)
  string                      file_path = 8;                  // 元数据对应的原始文件存储的路径
  string                      desc = 9;                       // 元数据的摘要(描述)
  uint64                      rows = 10;                      // 元数据对应原始文件的总行数
  uint64                      columns = 11;                   // 元数据对应原始文件的总列数
  uint64                      size = 12;                      // 元数据对应原始文件的总大小 (单位: byte)
  api.protobuf.OriginFileType file_type = 13;                 // 源文件的类型 (目前只有 csv)
  api.protobuf.MetaDataState  state = 14;                     // 元数据的状态 (0: 未知; 1: 还未发布的新表; 2: 已发布的表; 3: 已撤销的表)
  bool                        has_title = 15;                 // 元数据对应原始文件是否有标题行 (true: 包含; false: 不包含)
  repeated MetadataColumn     metadata_column_list = 16;      // 元数据对应原始文件对外暴露的列描述列表
  string                      industry = 17;                  // 元数据所属的行业
}

// 元数据中的列描述
message MetadataColumn {
  uint32 c_index = 1;           // 列所在原始文件中的索引值
  string c_name = 2;            // 列名称
  string c_type = 3;            // 列的数据类型
  uint32 c_size = 4;            // 列的大小 (单位: byte)
  string c_comment = 5;         // 列的描述
}

// =============================== For API =========================
// 元数据的摘要内容 (不包含详细 列描述)
message MetaDataSummary {
  string                        meta_data_id = 1;           // 元数据Id
  string                        origin_id = 2;              // 源文件Id
  string                        table_name = 3;             // 元数据名称|数据名称 (表名)
  string                        desc = 4;                   // 元数据的描述 (摘要)
  string                        file_path = 5;              // 源文件存放路径
  uint32                        rows = 6;                   // 源文件的行数
  uint32                        columns = 7;                // 源文件的列数
  uint32                        size = 8;                   // 源文件的大小 (单位: byte)
  api.protobuf.OriginFileType   file_type = 9;              // 源文件的类型 (目前只有 csv)
  bool                          has_title = 10;             // 源文件是否包含标题 (true: 包含; false: 不包含)
  string                        industry = 11;              // 元数据所属行业
  api.protobuf.MetaDataState    state = 12;                 // 元数据的状态 (0: 未知; 1: 还未发布的新表; 2: 已发布的表; 3: 已撤销的表)
}

// 元数据的详情信息
message MetadataDetail {
  MetaDataSummary         meta_data_summary = 1;            // 元数据摘要
  repeated MetadataColumn metadata_column_list = 2;         // 元数据对应原始文件对外暴露的列描述列表
  uint32                  total_task_count = 3;             // 该元数据参与过得任务数 (已完成的和正在执行的)
}



// 元数据的使用方式定义
message MetaDataUsage {
  api.protobuf.MetaDataUsageType  usage_type = 1;              // 元数据的使用方式 (0: 未定义; 1: 按照时间段来使用; 2: 按照次数来使用)
  uint64                          start_at = 2;                // 使用开始时间 (当 usage_type 为 1 时才需要的字段)
  uint64                          end_at = 3;                  // 使用结束时间 (当 usage_type 为 1 时才需要的字段)
  uint32                          times = 4;                   // 使用次数 (当 usage_type 为 2 时才需要的字段)
}

// 元数据使用授权
message MetaDataAuthority {
  api.protobuf.Organization owner = 1;                   // 元数据所属的组织信息
  string                    meta_data_id = 2;            // 元数据Id
  MetaDataUsage             usage = 3;                   // 元数据怎么使用
}

